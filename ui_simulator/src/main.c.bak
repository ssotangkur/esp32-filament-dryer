#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Define BUILD_FOR_SIMULATOR before including any headers
#define BUILD_FOR_SIMULATOR

/* Analog dial constants (copied from analog_dial.h to avoid dependency issues) */
#define ANALOG_DIAL_DIAMETER 210
#define ANALOG_DIAL_CONTAINER_WIDTH 160
#define ANALOG_DIAL_CONTAINER_HEIGHT 80
#define ANALOG_DIAL_VERT_SHIFT 90
#define ANALOG_DIAL_ANGLE_RANGE 70
#define ANALOG_DIAL_RANGE_START 0
#define ANALOG_DIAL_RANGE_END 120

#include "ui_stub.h"
#include "lvgl.h"

// Include the UI header files to get the function declarations
#include "../../main/ui/ui.h"

// Define the analog_dial_t struct here since the original header has issues with forward declaration
typedef struct analog_dial_t;

#include "../../main/ui/analog_dial.h"



// SDL and Emscripten related includes - in Emscripten environment
#ifdef __EMSCRIPTEN__
#include <SDL.h>
#include <emscripten.h>
#include <emscripten/html5.h>
#else
#define SDL_MAIN_HANDLED        /*To fix SDL's "undefined reference to WinMain" issue*/
#include <SDL2/SDL.h>
#endif



/*********************
 *      DEFINES
 *********************/

/*On OSX SDL needs different handling*/
#if defined(__APPLE__) && defined(TARGET_OS_MAC)
# if __APPLE__ && TARGET_OS_MAC
#define SDL_APPLE
# endif
#endif

/**********************
 *  STATIC PROTOTYPES
 **********************/
static void hal_init(void);
static int tick_thread(void * data);
static void memory_monitor(lv_timer_t * param);

/**********************
 *  STATIC VARIABLES
 **********************/
static lv_display_t  * disp1;

int monitor_hor_res = 320, monitor_ver_res = 170;

/**********************
 *   GLOBAL FUNCTIONS
 **********************/
void do_loop(void *arg);

int main(int argc, char ** argv)
{
    printf("Starting with screen resolution of %dx%d px\n", monitor_hor_res, monitor_ver_res);

    /*Initialize LVGL*/
    lv_init();

    /*Initialize the HAL (display, input devices, tick) for LVGL*/
    hal_init();

    /* Initialize the UI */
    init_ui();

#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop_arg(do_loop, NULL, 0, 1);  // 0 = run at browser requestAnimationFrame rate (~60fps)
#else
    while(1) {
        lv_timer_handler();
        usleep(5000);   // Sleep for 5ms to reduce CPU usage
    }
#endif
}

void do_loop(void *arg)
{
    /* Periodically call the lv_timer handler.
     * It could be done in a timer interrupt or an OS task too.*/
    lv_timer_handler();
}

/**********************
 *   STATIC FUNCTIONS
 **********************/

/**
 * Initialize the Hardware Abstraction Layer (HAL) for the Littlev graphics library
 */
static void hal_init(void)
{
    /* Create display for LVGL using the built-in display functions */
    lv_display_t * disp = lv_display_create(monitor_hor_res, monitor_ver_res);
    lv_display_set_resolution(disp, monitor_hor_res, monitor_ver_res);

    /* Set up display buffering */
    static lv_color_t buf1[320 * 100]; // Buffer for partial rendering (fixed size for 320px width)
    lv_display_set_buffers(disp, buf1, NULL, sizeof(buf1), LV_DISPLAY_RENDER_MODE_PARTIAL);

    /* Create a mouse input device */
    lv_indev_t * indev_mouse = lv_indev_create();
    lv_indev_set_type(indev_mouse, LV_INDEV_TYPE_POINTER);
    lv_indev_set_disp(indev_mouse, disp);

    /* Create a keyboard input device */
    lv_indev_t * indev_kb = lv_indev_create();
    lv_indev_set_type(indev_kb, LV_INDEV_TYPE_KEYPAD);
    lv_indev_set_disp(indev_kb, disp);

    /* Create a mousewheel input device */
    lv_indev_t * indev_enc = lv_indev_create();
    lv_indev_set_type(indev_enc, LV_INDEV_TYPE_ENCODER);
    lv_indev_set_disp(indev_enc, disp);
}

// UI implementation code (copied from ui.c and adapted)
static lv_obj_t *needle_line;

static void set_needle_line_value(lv_obj_t *obj, int32_t v)
{
  lv_scale_set_line_needle_value(obj, needle_line, 60, v);
}

/* Initialize user interface */
void init_ui(void)
{
  // Create only a single simple label to test basic functionality
  printf("UI initialization started - creating minimal test objects\n");

  /* Change the active screen's background color */
  lv_obj_set_style_bg_color(lv_screen_active(), lv_palette_darken(LV_PALETTE_GREY, 2), LV_PART_MAIN);

  lv_obj_set_layout(lv_screen_active(), LV_LAYOUT_FLEX);
  lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(lv_screen_active(), LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START);

  /* Create a single test label */
  lv_obj_t *test_label = lv_label_create(lv_screen_active());
  lv_label_set_text(test_label, "LVGL 9.x OK");

  /* Create round scale */
  lv_obj_t *scale_line = lv_scale_create(lv_screen_active());

  lv_obj_set_size(scale_line, 100, 100);
  lv_scale_set_mode(scale_line, LV_SCALE_MODE_ROUND_INNER);
  lv_obj_set_style_bg_opa(scale_line, LV_OPA_COVER, 0);
  lv_obj_set_style_bg_color(scale_line, lv_color_white(), 0);
  lv_obj_set_style_radius(scale_line, LV_RADIUS_CIRCLE, 0);
  lv_obj_set_style_clip_corner(scale_line, true, 0);
  lv_obj_align(scale_line, LV_ALIGN_LEFT_MID, LV_PCT(2), 0);

  lv_scale_set_label_show(scale_line, true);

  lv_scale_set_total_tick_count(scale_line, 31);
  lv_scale_set_major_tick_every(scale_line, 5);

  lv_obj_set_style_length(scale_line, 5, LV_PART_ITEMS);
  lv_obj_set_style_length(scale_line, 10, LV_PART_INDICATOR);
  lv_scale_set_range(scale_line, 10, 40);

  lv_scale_set_angle_range(scale_line, 270);
  lv_scale_set_rotation(scale_line, 135);

  needle_line = lv_line_create(scale_line);

  lv_obj_set_style_line_width(needle_line, 3, LV_PART_MAIN);
  lv_obj_set_style_line_color(needle_line, lv_palette_darken(LV_PALETTE_RED, 3), LV_PART_MAIN);
  lv_obj_set_style_line_rounded(needle_line, true, LV_PART_MAIN);

  set_needle_line_value(scale_line, 32);

  struct analog_dial_t *dial = create_analog_dial(lv_screen_active());
  set_analog_dial_value(dial, 75);

  /* Try any of the demos by uncommenting one of the lines below */
  // lv_demo_widgets();
  // lv_demo_keypad_encoder();
  // lv_demo_benchmark();
  // lv_demo_stress();

  printf("UI initialization completed - objects created successfully\n");
}

// Analog dial implementation code (copied from analog_dial.c and adapted)
struct analog_dial_t
{
  lv_obj_t *container;
  lv_obj_t *scale;
  lv_obj_t *needle_line;
  int32_t needle_length;
};

void set_analog_dial_value(struct analog_dial_t *dial, int32_t value)
{
  lv_scale_set_line_needle_value(
      dial->scale,
      dial->needle_line,
      dial->needle_length,
      value);
}

struct analog_dial_t *create_analog_dial(
    lv_obj_t *parent)
{
  /* Dial is bigger that the window it occupies so we need to wrap it
    in a container and use padding to shift it to the right location.
              ◄──container_width──►

             ┌──────Container──────┐
      ▲ ┌───────────────────────────────┐
      │ │    │                     │    │
      │ │    │                     │    │
      d │    │          +──────────┼────┼────
      i │    │                     │    │  |
      a │    │                     │    │  │
      l │    │                     │    │ Offset
      │ │    └─────────────────────┘    │  │
      d │                               │  ▼
      i │               +───────────────┼────
      a │                               │
      m │                               │
      e │                               │
      t │                               │
      e │                               │
      r │                               │
      │ │                               │
      ▼ └───────────────────────────────┘
          ◄────────dial_diameter────────►

  */

  /* Constants */
  int32_t major_tick_length = 10;
  int32_t major_tick_width = 1;
  int32_t minor_tick_length = 5;
  int32_t minor_tick_width = 1;

  /* Calculate padding values */
  int d2 = ANALOG_DIAL_DIAMETER / 2;
  int c2 = ANALOG_DIAL_CONTAINER_HEIGHT / 2;
  int horiz_padding = (ANALOG_DIAL_CONTAINER_WIDTH - ANALOG_DIAL_DIAMETER) / 2;
  int top_padding = d2 + ANALOG_DIAL_VERT_SHIFT - c2;
  int bottom_padding = d2 - ANALOG_DIAL_VERT_SHIFT - c2;

  struct analog_dial_t *dial = malloc(sizeof(struct analog_dial_t));

  lv_obj_t *container = lv_obj_create(parent);
  dial->container = container;
  lv_obj_set_style_bg_color(container, lv_color_white(), LV_PART_MAIN);
  // lv_obj_set_style_bg_opa(container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_pad_top(container, top_padding, LV_PART_MAIN);
  lv_obj_set_style_pad_left(container, horiz_padding, LV_PART_MAIN);
  lv_obj_set_style_pad_right(container, horiz_padding, LV_PART_MAIN);
  lv_obj_set_style_pad_bottom(container, bottom_padding, LV_PART_MAIN);
  lv_obj_set_size(container, ANALOG_DIAL_CONTAINER_WIDTH, ANALOG_DIAL_CONTAINER_HEIGHT);
  lv_obj_set_style_radius(container, 0, LV_PART_MAIN);
  lv_obj_set_style_border_width(container, 0, LV_PART_MAIN);
  /* Remove scrollbar */
  lv_obj_remove_flag(container, LV_OBJ_FLAG_SCROLLABLE);

  /* Create round scale */
  lv_obj_t *scale_line = lv_scale_create(container);
  dial->scale = scale_line;

  lv_obj_set_size(scale_line, ANALOG_DIAL_DIAMETER, ANALOG_DIAL_DIAMETER);
  lv_obj_set_style_radius(scale_line, 0, LV_PART_MAIN);
  lv_obj_set_style_border_width(scale_line, 0, LV_PART_MAIN);
  lv_obj_set_style_margin_all(scale_line, 0, LV_PART_MAIN);
  /* Set origin of scale to be top middle */
  // lv_obj_set_align(scale_line, LV_ALIGN_TOP_MID);
  lv_obj_center(scale_line);

  lv_scale_set_mode(scale_line, LV_SCALE_MODE_ROUND_OUTER);
  lv_obj_set_style_bg_opa(scale_line, LV_OPA_COVER, 0);
  lv_obj_set_style_bg_color(scale_line, lv_color_white(), 0);
  lv_obj_set_style_radius(scale_line, LV_RADIUS_CIRCLE, 0);
  lv_obj_set_style_clip_corner(scale_line, false, LV_PART_INDICATOR);
  lv_obj_set_style_clip_corner(scale_line, false, LV_PART_MAIN);
  lv_scale_set_draw_ticks_on_top(scale_line, true);

  lv_scale_set_label_show(scale_line, true);

  lv_scale_set_total_tick_count(scale_line, 31);
  lv_scale_set_major_tick_every(scale_line, 5);
  lv_obj_set_style_pad_radial(scale_line, -10, LV_PART_INDICATOR);
  lv_obj_set_style_text_font(scale_line, &lv_font_montserrat_14, LV_PART_INDICATOR);

  lv_obj_set_style_length(scale_line, 5, LV_PART_ITEMS);
  lv_obj_set_style_line_width(scale_line, 1, LV_PART_ITEMS);
  lv_obj_set_style_length(scale_line, 10, LV_PART_INDICATOR);
  lv_obj_set_style_line_width(scale_line, 1, LV_PART_INDICATOR);
  /* Rotate labels to match tick angle */
  // lv_obj_set_style_transform_rotation(scale_line, LV_SCALE_LABEL_ROTATE_MATCH_TICKS + 900, LV_PART_INDICATOR);

  lv_scale_set_range(scale_line, ANALOG_DIAL_RANGE_START, ANALOG_DIAL_RANGE_END);

  lv_scale_set_angle_range(scale_line, ANALOG_DIAL_ANGLE_RANGE);
  lv_scale_set_rotation(scale_line, 180 + (180 - ANALOG_DIAL_ANGLE_RANGE) / 2);

  lv_obj_t *needle_line = lv_line_create(scale_line);
  dial->needle_line = needle_line;

  lv_obj_set_style_line_width(needle_line, 1, LV_PART_MAIN);
  lv_obj_set_style_line_color(needle_line, lv_palette_darken(LV_PALETTE_RED, 3), LV_PART_MAIN);
  lv_obj_set_style_line_rounded(needle_line, true, LV_PART_MAIN);

  dial->needle_length = d2 + major_tick_length;

  set_analog_dial_value(dial, 53);
  // lv_scale_set_line_needle_value(scale_line, needle_line, d2 + major_tick_length, 53);

  return dial;
}

void free_analog_dial(struct analog_dial_t *dial)
{
  /* deletes recursively delete children too but we will still try to delete
     from bottom up explicitly */
  lv_obj_delete(dial->needle_line);
  lv_obj_delete(dial->scale);
  lv_obj_delete(dial->container);
  free(dial);
}